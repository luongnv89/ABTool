<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
<TITLE>Grammar GSL.g</TITLE>
</HEAD>
<BODY>
<table summary="" border="1" cellpadding="5">
<tr>
<td>
<font size="+2">Grammar GSL</font><br>
<a href="http://www.ANTLR.org">ANTLR</a>-generated HTML file from GSL.g
<p>
Terence Parr, <a href="http://www.magelang.com">MageLang Institute</a>
<br>ANTLR Version 2.7.7 (2006-11-01); 1989-2005
</td>
</tr>
</table>
<PRE>


/**
 * @author &lt;a href=&quot;mailto:jean.louis.boulanger@wanadoo.fr&quot;&gt;Jean-Louis Boulanger&lt;/a&gt;
 **/
Definition of tree parser GSL, which is a subclass of TreeParser.

	
	
<a name="traitement">traitement</a>
		:				 #( PO traitement traitement ) 
		|	<a href="GSL.html#apo">apo</a> 
		;
	
	
<a name="apo">apo</a>
		:				 #( APO structure ) 
		;
	
	
<a name="structure">structure</a>
		:				 #( B_IMPLIES predicate goal 
	#structure = #(B_IMPLIES ,#pr ,#gg);
 ) 
		;
	
	
<a name="predicate">predicate</a>
		:	BTRUE 
		|				 #( t51:B_NOT predicate ) 
		|				 #( t52:B_RAN predicate ) 
		|				 #( t53:B_DOM predicate ) 
		|				 #( t54:B_AND predicate predicate ) 
		|				 #( t2:"or" predicate predicate ) 
		|				 #( t3:B_IMPLIES predicate predicate ) 
		|				 #( t4:B_EQUIV predicate predicate ) 
		|				 #( t5:B_MULT predicate predicate ) 
		|				 #( t6:B_POWER predicate predicate ) 
		|				 #( t7:B_DIV predicate predicate ) 
		|				 #( t8:"mod" predicate predicate ) 
		|				 #( t9:UNARY_ADD predicate ) 
		|				 #( t10:UNARY_MINUS predicate ) 
		|				 #( t11:B_ADD predicate predicate ) 
		|				 #( t12:B_MINUS predicate predicate ) 
		|				 #( t13:B_EQUAL predicate predicate ) 
		|				 #( t14:B_LESS predicate predicate ) 
		|				 #( t15:B_GREATER predicate predicate ) 
		|				 #( t16:B_NOTEQUAL predicate predicate ) 
		|				 #( t17:B_LESSTHANEQUAL predicate predicate ) 
		|				 #( t18:B_GREATERTHANEQUAL predicate predicate ) 
		|				 #( t19:B_INSET predicate predicate ) 
		|				 #( t20:B_NOTINSET predicate predicate ) 
		|				 #( t21:B_SUBSET predicate predicate ) 
		|				 #( t22:B_NOTSUBSET predicate predicate ) 
		|				 #( t23:B_STRICTSUBSET predicate predicate ) 
		|				 #( t24:B_NOTSTRICTSBSET predicate predicate ) 
		|				 #( t25:B_CONCATSEQ predicate predicate ) 
		|				 #( t26:B_PREAPPSEQ predicate predicate ) 
		|				 #( t27:B_APPSEQ predicate predicate ) 
		|				 #( t28:B_PREFIXSEQ predicate predicate ) 
		|				 #( t29:B_SUFFIXSEQ predicate predicate ) 
		|				 #( t30:B_RELATION predicate predicate ) 
		|				 #( t31:B_PARTIAL predicate predicate ) 
		|				 #( t32:B_TOTAL predicate predicate ) 
		|				 #( t33:B_PARTIAL_INJECT predicate predicate ) 
		|				 #( t34:B_TOTAL_INJECT predicate predicate ) 
		|				 #( t35:B_PARTIAL_SURJECT predicate predicate ) 
		|				 #( t36:B_TOTAL_SURJECT predicate predicate ) 
		|				 #( t37:B_BIJECTION predicate predicate ) 
		|				 #( t38:B_DOMAINRESTRICT predicate predicate ) 
		|				 #( t39:B_RANGERESTRICT predicate predicate ) 
		|				 #( B_DOMAINSUBSTRACT predicate predicate ) 
		|				 #( B_RANGESUBSTRACT predicate predicate ) 
		|				 #( B_OVERRIDEFORWARD predicate predicate ) 
		|				 #( B_OVERRIDEBACKWARD predicate predicate ) 
		|				 #( B_RELPROD predicate predicate ) 
		|				 #( B_UNION predicate predicate ) 
		|				 #( B_INTER predicate predicate ) 
		|				 #( B_MAPLET predicate predicate ) 
		|				 #( LIST_VAR predicate predicate ) 
		|	<a href="GSL.html#basic_sets">basic_sets</a> 
		|	<a href="GSL.html#cbasic_value">cbasic_value</a> 
		|				 #( "bool" predicate ) 
		|				 #( B_BRACKOPEN listPredicate ) 
		|				 #( B_RANGE predicate predicate ) 
		|	B_EMPTYSET 
		|				 #( B_CURLYOPEN cvalue_set ) 
		|	B_SEQEMPTY 
		|	<a href="GSL.html#is_record">is_record</a> 
		|	<a href="GSL.html#quantification">quantification</a> 
		|	<a href="GSL.html#q_lambda">q_lambda</a> 
		;
	
	
<a name="goal">goal</a>
		:				 #( SUBST_TO 
	System.out.println("GSL-goal : on debute ");
 predicate 
	System.out.println("GSL-goal :pr = " + #pr.toStringList());
 gsl#pr  
	#goal = (MyNode) astFactory.dupTree(#res);
	System.out.println("GSL-goal : on finit avec " + #res.toStringList());
 ) 
		|				 #( t:BTRUE 
    #goal = #t;
 ) 
		;
	
	
<a name="gsl">gsl</a>
		:				 #( GSL_SUCH predicate gslpr 
	#result  = #(#[B_AND,"&"],     #p1, #res);
	System.out.println("gsl1 -- on a :" + #result.toStringList());	
 ) 
		|				 #( GSL_FOR_SUCH listTypedIdentifier gslpr 
	#result  = #(#[B_FORALL,"!"],  #ll, #res);
	System.out.println("gsl2 -- on a :" + #result.toStringList());
 ) 
		|				 #( GSL_GUARD predicate gslpr 
	#result  = #(#[B_IMPLIES,"=>"],#p2, #res);
	System.out.println("gsl3 -- on a :" + #result.toStringList());
 ) 
		|				 #( "skip" 
	#result	= (MyNode) astFactory.dupTree(#pr);
	System.out.println("gsl4 -- on a :" + #result.toStringList());
 ) 
		|				 #( B_SIMPLESUBST afc predicate 
	aaffecter   = true;
	System.out.println("debut gsl ':=' -- on a :" + #pr.toStringList());
	#name        = (MyNode) astFactory.dupTree(#lf); 
        #transfert   = (MyNode) astFactory.dupTree(#p5); 
        MyNode tmp  = predicate_normalize(#pr);
        #result      = (MyNode) astFactory.dupTree(#tmp);

        aaffecter   = false;
	System.out.println("fin gsl ':=' -- on a :" + #tmp.toStringList());
 ) 
		|				 #( SEQUENTIAL gslpr gslr1 
	#result = (MyNode) astFactory.dupTree(pr);
	System.out.println("gsl ';' -- on a :" + #result.toStringList());
 ) 
		|				 #( PARALLEL gslpr gslpr 
	#result = #(#[B_AND,"&"],     #r1, #r2);
	System.out.println("gsl '||' -- on a :" + #result.toStringList());
 ) 
		;
	
	
<a name="listTypedIdentifier">listTypedIdentifier</a>
		:				 #( B_COMMA listTypedIdentifier 

 listTypedIdentifier ) 
		|	<a href="GSL.html#typedIdentifier">typedIdentifier</a> 
		;
	
	
<a name="afc">afc</a>
		:				 #( FUNC_CALL_PARAM afc listPredicate ) 
		|				 #( t1:B_QUOTEIDENT afc afc ) 
		|	<a href="GSL.html#nameRenamed">nameRenamed</a> 
		;
	
	
<a name="listPredicate">listPredicate</a>
		:				 #( tt:B_COMMA listPredicate predicate ) 
		|	<a href="GSL.html#predicate">predicate</a> 
		;
	
	
<a name="nameRenamed">nameRenamed</a>
		:	B_IDENTIFIER 
		|				 #( tt:B_POINT nameRenamed nameRenamed 
    if (aaffecter== true)
    {
        if (tt.toString().compareTo(#name.toString())==0)
        {
            #nameRenamed = (MyNode) astFactory.dupTree(#transfert);
        }
        else
        {
            #nameRenamed =#(#tt,#n2,#n3);
        }
    }
    else
    {
        #nameRenamed =#(#tt,#n2,#n3);
    }
 ) 
		;
	
	
/** 
 *  PREDICATE 
 **/
<a name="predicate_normalize">predicate_normalize</a>
		:	<a href="GSL.html#predicate">predicate</a> 
		;
	
	
<a name="basic_sets">basic_sets</a>
		:	&quot;INT&quot; 
		|	&quot;INT1&quot; 
		|	&quot;INTEGER&quot; 
		|	&quot;INTEGER1&quot; 
		|	&quot;BOOL&quot; 
		|	&quot;NAT&quot; 
		|	&quot;NAT1&quot; 
		|	&quot;NATURAL&quot; 
		|	&quot;NATURAL1&quot; 
		|	&quot;STRING&quot; 
		;
	
	
<a name="cbasic_value">cbasic_value</a>
		:	B_ASTRING 
		|	B_NUMBER 
		|				 #( B_TILDE predicate ) 
		|	<a href="GSL.html#nameRenamedDecorated">nameRenamedDecorated</a> 
		|				 #( B_LPAREN predicate list_New_Predicate ) 
		|				 #( PARENT pred_func_composition ) 
		|				 #( t4:B_QUOTEIDENT predicate predicate 
    if (aaffecter)
    {
        if (t4.toString().compareTo(name.toString())==0)
        {
            #cbasic_value = (MyNode) astFactory.dupTree(#transfert);
        }
        else
        {
            #cbasic_value =#(#t4,#p1,#p2);
        }
    }
    else
    {
        #cbasic_value =#(#t4,#p1,#p2);
    }
 ) 
		|				 #( APPLY_TO predicate predicate ) 
		|	&quot;TRUE&quot; 
		|	&quot;FALSE&quot; 
		;
	
	
<a name="cvalue_set">cvalue_set</a>
		:				 #( B_SUCH list_var predicate ) 
		|				 #( B_COMMA cvalue_set predicate ) 
		|	<a href="GSL.html#predicate">predicate</a> 
		;
	
	
<a name="is_record">is_record</a>
		:				 #( t1:"rec" listrecord ) 
		|				 #( t01:"struct" listrecord ) 
		;
	
	
<a name="quantification">quantification</a>
		:				 #( t70:B_FORALL list_var predicate ) 
		|				 #( t71:B_EXISTS list_var predicate ) 
		;
	
	
<a name="q_lambda">q_lambda</a>
		:				 #( t1:B_LAMBDA q_operande ) 
		|				 #( t2:"PI" q_operande ) 
		|				 #( t3:"SIGMA" q_operande ) 
		|				 #( t4:"UNION" q_operande ) 
		|				 #( t5:"INTER" q_operande ) 
		;
	
	
<a name="list_var">list_var</a>
		:				 #( B_LPAREN list_identifier ) 
		|	<a href="GSL.html#list_identifier">list_identifier</a> 
		;
	
	
<a name="nameRenamedDecorated">nameRenamedDecorated</a>
		:				 #( t1:B_CPRED nameRenamed 
    if (aaffecter== true)
    { 
        if (t1.toString().compareTo(#name.toString())==0)
        {
            #nameRenamedDecorated = (MyNode) astFactory.dupTree(#transfert);
        }
        else
        {
            #nameRenamedDecorated =#(#t1,#n1);
        }
    }
    else
    {
        #nameRenamedDecorated =#(#t1,#n1);
    }
 ) 
		|	<a href="GSL.html#nameRenamed">nameRenamed</a> 
		;
	
	
<a name="list_New_Predicate">list_New_Predicate</a>
		:				 #( tt:B_COMMA list_New_Predicate new_predicate ) 
		|	<a href="GSL.html#new_predicate">new_predicate</a> 
		;
	
	
<a name="pred_func_composition">pred_func_composition</a>
		:				 #( t1:B_SEMICOLON pred_func_composition predicate ) 
		|				 #( t2:B_PARALLEL pred_func_composition predicate ) 
		|				 #( t3:B_COMMA pred_func_composition predicate ) 
		|	<a href="GSL.html#predicate">predicate</a> 
		;
	
	
<a name="q_operande">q_operande</a>
		:				 #( t1:B_SUCH list_var predicate predicate ) 
		;
	
	
<a name="list_identifier">list_identifier</a>
		:				 #( tt:B_COMMA list_identifier n1:B_IDENTIFIER ) 
		|	B_IDENTIFIER 
		;
	
	
<a name="typedIdentifier">typedIdentifier</a>
		:				 #( B_INSET nameRenamed predicate ) 
		|	<a href="GSL.html#nameRenamed">nameRenamed</a> 
		;
	
	
<a name="listrecord">listrecord</a>
		:				 #( tt:B_COMMA listrecord a_record ) 
		|	<a href="GSL.html#a_record">a_record</a> 
		;
	
	
<a name="a_record">a_record</a>
		:				 #( B_SELECTOR name:B_IDENTIFIER predicate ) 
		|	<a href="GSL.html#predicate">predicate</a> 
		;
	
	
<a name="new_predicate">new_predicate</a>
		:				 #( t1:B_SEMICOLON new_predicate predicate ) 
		|				 #( t2:B_PARALLEL new_predicate predicate ) 
		|	<a href="GSL.html#predicate">predicate</a> 
		;

