<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
<TITLE>Grammar Substitution.g</TITLE>
</HEAD>
<BODY>
<table summary="" border="1" cellpadding="5">
<tr>
<td>
<font size="+2">Grammar Substitution</font><br>
<a href="http://www.ANTLR.org">ANTLR</a>-generated HTML file from Substitution.g
<p>
Terence Parr, <a href="http://www.magelang.com">MageLang Institute</a>
<br>ANTLR Version 2.7.7 (2006-11-01); 1989-2005
</td>
</tr>
</table>
<PRE>


/**
 * @author &lt;a href=&quot;mailto:jean.louis.boulanger@wanadoo.fr&quot;&gt;Jean-Louis Boulanger&lt;/a&gt;
 **/
Definition of tree parser Substitution, which is a subclass of TreeParser.

	
	
<a name="buildAndEvalGoal">buildAndEvalGoal</a>
		:	
		;
	
	
<a name="agoal">agoal</a>
		:				 #( SUBST_TO instruction predicate 
    if (ii == null)                       // cas du skip qui produit null
		res = #pp;
	else	                              // cas general
		res = #(SUBST_TO, #pp,  #ii);
 ) 
		|				 #( BTRUE 
   res = ##;
 ) 
		;
	
	
<a name="instruction">instruction</a>
		:				 #( t1:PARALLEL instruction instruction ) 
		|				 #( t2:SEQUENTIAL instruction instruction ) 
		|				 #( "skip" 
	#instruction = null;
 ) 
		|				 #( "BEGIN" instruction 
	#instruction = #i4;
 ) 
		|				 #( "PRE" predicate instruction 
	#instruction = #([GSL_SUCH,"|"], p5, i5);
 ) 
		|				 #( "ASSERT" predicate instruction 
// A VERIFIER dans le BBOOK
	#instruction = #([B_AND,"&"], #p6, #([GSL_GUARD,"==>"],#p6,#i6));
 ) 
		|				 #( "IF" predicate branche_thentp7 ( branche_elsiftp7 )* ( branche_elsetp7 | ) 
// A VERIFIER dans le BBOOK
//	#instruction = #([B_AND,"&"], #p6, #([GSL_GUARD,"==>"],#p6,#i6));
 ) 
		|				 #( t8:"CHOICE" list_or 
	#instruction = #l8;
 ) 
		|				 #( t9:"CASE" predicate branche_either ( branche_or )* ( branche_elsett9 | ) ) 
		|				 #( t10:"ANY" listTypedIdentifier predicate instruction 
	#instruction = #([GSL_FOR_SUCH, "@"],l10, #([GSL_GUARD,"==>"], p10,i10));
 ) 
		|				 #( t11:"LET" listTypedIdentifier list_equal instruction 
	#instruction = #([GSL_FOR_SUCH, "@"],l11, #([GSL_GUARD,"==>"], p11,i11));
 ) 
		|				 #( t12:"SELECT" predicate branche_thentt12 ( branche_when )* ( branche_elsett12 | ) ) 
		|				 #( t13:"WHILE" predicate instruction variant_or_no ) 
		|				 #( tt:"VAR" listTypedIdentifier instruction 
	#instruction = #([GSL_FOR_SUCH,"@"],l14,i14);
 ) 
		|	<a href="Substitution.html#simple_affect">simple_affect</a> 
		;
	
	
/** 
 *  PREDICATE 
 **/
<a name="predicate">predicate</a>
		:				 #( t:BTRUE 
	#predicate = #t;
 ) 
		|				 #( a1:B_NOT predicate ) 
		|				 #( a2:B_RAN predicate ) 
		|				 #( a3:B_DOM predicate ) 
		|				 #( t1:B_AND predicate predicate ) 
		|				 #( t2:"or" predicate predicate ) 
		|				 #( t3:B_IMPLIES predicate predicate ) 
		|				 #( t4:B_EQUIV predicate predicate ) 
		|				 #( t5:B_MULT predicate predicate ) 
		|				 #( t6:B_POWER predicate predicate ) 
		|				 #( t7:B_DIV predicate predicate ) 
		|				 #( t8:"mod" predicate predicate ) 
		|				 #( t9:UNARY_ADD predicate ) 
		|				 #( t10:UNARY_MINUS predicate ) 
		|				 #( t11:B_ADD predicate predicate ) 
		|				 #( t12:B_MINUS predicate predicate ) 
		|				 #( t13:B_EQUAL predicate predicate ) 
		|				 #( t14:B_LESS predicate predicate ) 
		|				 #( t15:B_GREATER predicate predicate ) 
		|				 #( t16:B_NOTEQUAL predicate predicate ) 
		|				 #( t17:B_LESSTHANEQUAL predicate predicate ) 
		|				 #( t18:B_GREATERTHANEQUAL predicate predicate ) 
		|				 #( t19:B_INSET predicate predicate ) 
		|				 #( t20:B_NOTINSET predicate predicate ) 
		|				 #( t21:B_SUBSET predicate predicate ) 
		|				 #( t22:B_NOTSUBSET predicate predicate ) 
		|				 #( t23:B_STRICTSUBSET predicate predicate ) 
		|				 #( t24:B_NOTSTRICTSBSET predicate predicate ) 
		|				 #( t25:B_CONCATSEQ predicate predicate ) 
		|				 #( t26:B_PREAPPSEQ predicate predicate ) 
		|				 #( t27:B_APPSEQ predicate predicate ) 
		|				 #( t28:B_PREFIXSEQ predicate predicate ) 
		|				 #( t29:B_SUFFIXSEQ predicate predicate ) 
		|				 #( t30:B_RELATION predicate predicate ) 
		|				 #( t31:B_PARTIAL predicate predicate ) 
		|				 #( t32:B_TOTAL predicate predicate ) 
		|				 #( t33:B_PARTIAL_INJECT predicate predicate ) 
		|				 #( t34:B_TOTAL_INJECT predicate predicate ) 
		|				 #( t35:B_PARTIAL_SURJECT predicate predicate ) 
		|				 #( t36:B_TOTAL_SURJECT predicate predicate ) 
		|				 #( t37:B_BIJECTION predicate predicate ) 
		|				 #( t38:B_DOMAINRESTRICT predicate predicate ) 
		|				 #( t39:B_RANGERESTRICT predicate predicate ) 
		|				 #( t40:B_DOMAINSUBSTRACT predicate predicate ) 
		|				 #( t41:B_RANGESUBSTRACT predicate predicate ) 
		|				 #( t42:B_OVERRIDEFORWARD predicate predicate ) 
		|				 #( t43:B_OVERRIDEBACKWARD predicate predicate ) 
		|				 #( t44:B_RELPROD predicate predicate ) 
		|				 #( t45:B_UNION predicate predicate ) 
		|				 #( t46:B_INTER predicate predicate ) 
		|				 #( t48:B_MAPLET predicate predicate ) 
		|				 #( t49:LIST_VAR predicate predicate ) 
		|	<a href="Substitution.html#cset_description">cset_description</a> 
		;
	
	
/** 
 *  Root Rule
 **/
<a name="traitement">traitement</a>
		:				 #( PO traitement traitement ) 
		|	<a href="Substitution.html#a_PO">a_PO</a> 
		;
	
	
<a name="a_PO">a_PO</a>
		:				 #( APO info ) 
		;
	
	
<a name="info">info</a>
		:				 #( B_IMPLIES predicate goal ) 
		;
	
	
<a name="goal">goal</a>
		:				 #( SUBST_TO instruction predicate 
	if (ii == null)
		// cas du skip qui produit null
		#goal = #pp;
	else	// cas general
		#goal = #(SUBST_TO, #pp,  #ii);
 ) 
		|				 #( t:BTRUE 
    #goal = #t;
 ) 
		;
	
	
<a name="branche_then">branche_then</a>
		:				 #( "THEN" instruction 
	#branche_then = #([GSL_GUARD,"==>"], pr, i);
 ) 
		;
	
	
<a name="branche_elsif">branche_elsif</a>
		:				 #( t1:"ELSIF" predicate instruction 
	#branche_elsif = #([GSL_GUARD,"==>"], #([B_AND,"&"],#([B_NOT,"NOT"],pr),p), i);
 ) 
		;
	
	
<a name="branche_else">branche_else</a>
		:				 #( tt:"ELSE" instruction 
	#branche_else = #([GSL_GUARD,"==>"], #([B_NOT,"NOT"],pr), i);
 ) 
		;
	
	
<a name="list_or">list_or</a>
		:				 #( t1:"OR" list_or instruction 
	#list_or	= #([GSL_GUARD,"==>"],#l1,#i1);
 ) 
		|	<a href="Substitution.html#instruction">instruction</a> 
		;
	
	
<a name="branche_either">branche_either</a>
		:				 #( "EITHER" predicate instruction 
	#branche_either = #([GSL_GUARD,"==>"],#p,#i);
 ) 
		;
	
	
<a name="branche_or">branche_or</a>
		:				 #( "OR" predicate instruction 
	#branche_or = #([GSL_GUARD,"==>"],#p,#i);
 ) 
		;
	
	
<a name="listTypedIdentifier">listTypedIdentifier</a>
		:				 #( B_COMMA listTypedIdentifier listTypedIdentifier ) 
		|	<a href="Substitution.html#typedIdentifier">typedIdentifier</a> 
		;
	
	
<a name="list_equal">list_equal</a>
		:				 #( B_AND list_equal an_equal ) 
		|	<a href="Substitution.html#an_equal">an_equal</a> 
		;
	
	
<a name="branche_when">branche_when</a>
		:				 #( "WHEN" predicate instruction 
	#branche_when = #([GSL_GUARD,"==>"],#p,#i);
 ) 
		;
	
	
<a name="variant_or_no">variant_or_no</a>
		:	&quot;VARIANT&quot; <a href="Substitution.html#predicate">predicate</a> &quot;INVARIANT&quot; <a href="Substitution.html#predicate">predicate</a> 
		|	&quot;INVARIANT&quot; <a href="Substitution.html#predicate">predicate</a> &quot;VARIANT&quot; <a href="Substitution.html#predicate">predicate</a> 
		;
	
	
<a name="simple_affect">simple_affect</a>
		:				 #( t1:B_SIMPLESUBST list_func_call listPredicate ) 
		|				 #( t2:B_OUT list_func_call func_call ) 
		|				 #( t3:INSET list_func_call predicate ) 
		|				 #( t4:B_BECOME_ELEM list_func_call predicate 
    // ForALL Y WHERE [Y:=list_func_call]predicate THEN list_func_call := Y END
    // @ YList. [YList := list_func_call]predicate => list_func_call := YLIst

//#simple_affcet = #([GSL_FOR_SUCH, "@"],l11, #([GSL_GUARD,"==>"], p11,i11));
 ) 
		|	<a href="Substitution.html#a_func_call">a_func_call</a> 
		;
	
	
<a name="an_equal">an_equal</a>
		:				 #( B_EQUAL B_IDENTIFIER predicate ) 
		;
	
	
<a name="func_call">func_call</a>
		:				 #( t1:B_TILDE func_call ) 
		|				 #( t2:APPLY_TO func_call list_New_Predicate ) 
		|				 #( t3:B_LPAREN func_call list_New_Predicate ) 
		|				 #( t4:B_QUOTEIDENT func_call func_call ) 
		|	<a href="Substitution.html#nameRenamed">nameRenamed</a> 
		;
	
	
<a name="list_New_Predicate">list_New_Predicate</a>
		:				 #( tt:B_COMMA list_New_Predicate new_predicate ) 
		|	<a href="Substitution.html#new_predicate">new_predicate</a> 
		;
	
	
<a name="nameRenamed">nameRenamed</a>
		:	B_IDENTIFIER 
		|				 #( tt:B_POINT nameRenamed nameRenamed ) 
		;
	
	
<a name="func_param">func_param</a>
		:	<a href="Substitution.html#list_New_Predicate">list_New_Predicate</a> 
		;
	
	
<a name="new_predicate">new_predicate</a>
		:				 #( t1:B_SEMICOLON new_predicate predicate ) 
		|				 #( t2:B_PARALLEL new_predicate predicate ) 
		|	<a href="Substitution.html#predicate">predicate</a> 
		;
	
	
<a name="nameRenamedDecorated">nameRenamedDecorated</a>
		:				 #( B_CPRED nameRenamed ) 
		|	<a href="Substitution.html#nameRenamed">nameRenamed</a> 
		;
	
	
<a name="nameRenameDecoratedInverted">nameRenameDecoratedInverted</a>
		:				 #( B_TILDE nameRenamedDecorated ) 
		|	<a href="Substitution.html#nameRenamedDecorated">nameRenamedDecorated</a> 
		;
	
	
<a name="list_identifier">list_identifier</a>
		:				 #( tt:B_COMMA list_identifier n1:B_IDENTIFIER ) 
		|	B_IDENTIFIER 
		;
	
	
<a name="listPredicate">listPredicate</a>
		:				 #( tt:B_COMMA listPredicate predicate ) 
		|	<a href="Substitution.html#predicate">predicate</a> 
		;
	
	
<a name="a_func_call">a_func_call</a>
		:	<a href="Substitution.html#afc">afc</a> 
		;
	
	
<a name="afc">afc</a>
		:				 #( FUNC_CALL_PARAM afc listPredicate ) 
		|				 #( t1:B_QUOTEIDENT afc afc ) 
		|	<a href="Substitution.html#nameRenamed">nameRenamed</a> 
		;
	
	
<a name="list_func_call">list_func_call</a>
		:				 #( tt:B_COMMA list_func_call a_func_call ) 
		|	<a href="Substitution.html#a_func_call">a_func_call</a> 
		;
	
	
<a name="cset_description">cset_description</a>
		:	<a href="Substitution.html#basic_sets">basic_sets</a> 
		|	<a href="Substitution.html#cbasic_value">cbasic_value</a> 
		|				 #( "bool" predicate ) 
		|				 #( B_BRACKOPEN listPredicate ) 
		|				 #( B_RANGE predicate predicate ) 
		|	B_EMPTYSET 
		|				 #( B_CURLYOPEN cvalue_set ) 
		|	B_SEQEMPTY 
		|	<a href="Substitution.html#is_record">is_record</a> 
		|	<a href="Substitution.html#quantification">quantification</a> 
		|	<a href="Substitution.html#q_lambda">q_lambda</a> 
		;
	
	
<a name="basic_sets">basic_sets</a>
		:	&quot;INT&quot; 
		|	&quot;INT1&quot; 
		|	&quot;INTEGER&quot; 
		|	&quot;INTEGER1&quot; 
		|	&quot;BOOL&quot; 
		|	&quot;NAT&quot; 
		|	&quot;NAT1&quot; 
		|	&quot;NATURAL&quot; 
		|	&quot;NATURAL1&quot; 
		|	&quot;STRING&quot; 
		;
	
	
<a name="cbasic_value">cbasic_value</a>
		:	B_ASTRING 
		|	B_NUMBER 
		|				 #( B_TILDE predicate ) 
		|	<a href="Substitution.html#nameRenamedDecorated">nameRenamedDecorated</a> 
		|				 #( B_LPAREN predicate list_New_Predicate ) 
		|				 #( PARENT pred_func_composition ) 
		|				 #( B_QUOTEIDENT predicate predicate ) 
		|				 #( APPLY_TO predicate predicate ) 
		|	&quot;TRUE&quot; 
		|	&quot;FALSE&quot; 
		;
	
	
<a name="cvalue_set">cvalue_set</a>
		:				 #( B_SUCH list_var predicate ) 
		|				 #( B_COMMA cvalue_set predicate ) 
		|	<a href="Substitution.html#predicate">predicate</a> 
		;
	
	
<a name="is_record">is_record</a>
		:				 #( "rec" listrecord ) 
		|				 #( "struct" listrecord ) 
		;
	
	
<a name="quantification">quantification</a>
		:				 #( B_FORALL list_var predicate ) 
		|				 #( B_EXISTS list_var predicate ) 
		;
	
	
<a name="q_lambda">q_lambda</a>
		:				 #( B_LAMBDA q_operande ) 
		|				 #( "PI" q_operande ) 
		|				 #( "SIGMA" q_operande ) 
		|				 #( "UNION" q_operande ) 
		|				 #( "INTER" q_operande ) 
		;
	
	
<a name="list_var">list_var</a>
		:				 #( B_LPAREN list_identifier ) 
		|	<a href="Substitution.html#list_identifier">list_identifier</a> 
		;
	
	
<a name="pred_func_composition">pred_func_composition</a>
		:				 #( B_SEMICOLON pred_func_composition predicate ) 
		|				 #( B_PARALLEL pred_func_composition predicate ) 
		|				 #( B_COMMA pred_func_composition predicate ) 
		|	<a href="Substitution.html#predicate">predicate</a> 
		;
	
	
<a name="q_operande">q_operande</a>
		:				 #( t1:B_SUCH list_var predicate predicate ) 
		;
	
	
<a name="typedIdentifier">typedIdentifier</a>
		:				 #( B_INSET nameRenamed predicate ) 
		|	<a href="Substitution.html#nameRenamed">nameRenamed</a> 
		;
	
	
<a name="listrecord">listrecord</a>
		:				 #( B_COMMA listrecord a_record ) 
		|	<a href="Substitution.html#a_record">a_record</a> 
		;
	
	
<a name="a_record">a_record</a>
		:				 #( B_SELECTOR B_IDENTIFIER predicate ) 
		|	<a href="Substitution.html#predicate">predicate</a> 
		;
	
	
<a name="dummy">dummy</a>
		:	GSL_SUCH 
		|	GSL_FOR_SUCH 
		|	GSL_GUARD 
		|	GSL_BOUNDED 
		;

