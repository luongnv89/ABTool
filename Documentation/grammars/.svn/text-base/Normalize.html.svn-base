<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
<TITLE>Grammar Normalize.g</TITLE>
</HEAD>
<BODY>
<table summary="" border="1" cellpadding="5">
<tr>
<td>
<font size="+2">Grammar Normalize</font><br>
<a href="http://www.ANTLR.org">ANTLR</a>-generated HTML file from Normalize.g
<p>
Terence Parr, <a href="http://www.magelang.com">MageLang Institute</a>
<br>ANTLR Version 2.7.7 (2006-11-01); 1989-2005
</td>
</tr>
</table>
<PRE>


Definition of tree parser Normalize, which is a subclass of TreeParser.

	
	
/**
 *	La regle &quot;composant&quot; permet de definir le point d&#039;entree pour realiser le typage.
 **/
<a name="composant">composant</a>
		:				 #( "MACHINE" abstract_m = true ; paramName clauses ) 
		|				 #( "REFINEMENT" abstract_m = true ; paramName clauses ) 
		|				 #( "IMPLEMENTATION" abstract_m = false; paramName clauses ) 
		|				 #( "SYSTEM" abstract_m = true ; paramName clauses ) 
		;
	
	
/**
 * This rule is used for defined all Name with or without parameters
 **/
<a name="paramName">paramName</a>
		:				 #( bb:B_LPAREN n1:B_IDENTIFIER listTypedIdentifier 
    String ss = #n1.getText();
    System.out.println("paramName =" + ss);

	#bb.memorizeOpname(#n1.getText());
    #n1.memorizeOpname(#n1.getText());

//	For definition, we prepare the work
	def_name 	= (MyNode) astFactory.dupTree(#n1);
	def_param	= (MyNode) astFactory.dupTree(#l1);
 ) 
		|	B_IDENTIFIER 
		;
	
	
<a name="clauses">clauses</a>
		:	( <a href="Normalize.html#clause">clause</a> )* 
		;
	
	
<a name="clause">clause</a>
		:				 #( "CONSTRAINTS" predicate ) 
		|				 #( "EXTENDS" listInstanciation ) 
		|				 #( "USES" listNames ) 
		|				 #( "INCLUDES" listInstanciation ) 
		|				 #( "SEES" listNames ) 
		|				 #( "IMPORTS" listInstanciation ) 
		|				 #( "PROMOTES" listNames ) 
		|				 #( "REFINES" B_IDENTIFIER ) 
		|				 #( "CONSTANTS" listTypedIdentifier ) 
		|				 #( "CONCRETE_CONSTANTS" listTypedIdentifier ) 
		|				 #( "VISIBLE_CONSTANTS" listTypedIdentifier ) 
		|				 #( "ABSTRACT_CONSTANTS" listTypedIdentifier ) 
		|				 #( "HIDDEN_CONSTANTS" listTypedIdentifier ) 
		|				 #( "SETS" sets_declaration ) 
		|				 #( "VALUES" list_valuation ) 
		|				 #( "PROPERTIES" predicate ) 
		|				 #( "VARIABLES" listTypedIdentifier ) 
		|				 #( "ABSTRACT_VARIABLES" listTypedIdentifier ) 
		|				 #( "VISIBLE_VARIABLES" listTypedIdentifier ) 
		|				 #( "CONCRETE_VARIABLES" listTypedIdentifier ) 
		|				 #( "HIDDEN_VARIABLES" listTypedIdentifier ) 
		|				 #( "INVARIANT" predicate ) 
		|				 #( "DEFINITIONS" 
            def = true;
 list_def 
            def = false;
 ) 
		|				 #( "INITIALISATION" instruction ) 
		|				 #( "OPERATIONS" listOperation ) 
		|				 #( "ASSERTIONS" list_assertions ) 
		|				 #( "EVENTS" listOperation ) 
		|				 #( "MODALITIES" predicate ) 
		|				 #( "DYNAMICS" predicate_with_prime ) 
		;
	
	
/** 
 * Clause Predicate
 **/
<a name="predicate">predicate</a>
		:				 #( B_AND predicate predicate ) 
		|				 #( "or" predicate predicate ) 
		|				 #( B_IMPLIES predicate predicate ) 
		|				 #( B_EQUIV predicate predicate ) 
		|				 #( B_MULT predicate predicate ) 
		|				 #( B_POWER predicate predicate ) 
		|				 #( B_DIV predicate predicate ) 
		|				 #( "mod" predicate predicate ) 
		|				 #( UNARY_ADD predicate ) 
		|				 #( UNARY_MINUS predicate ) 
		|				 #( B_ADD predicate predicate ) 
		|				 #( B_MINUS predicate predicate ) 
		|				 #( B_EQUAL predicate predicate ) 
		|				 #( B_LESS predicate predicate ) 
		|				 #( B_GREATER predicate predicate ) 
		|				 #( B_NOTEQUAL predicate predicate ) 
		|				 #( B_LESSTHANEQUAL predicate predicate ) 
		|				 #( B_GREATERTHANEQUAL predicate predicate ) 
		|				 #( B_INSET ml_var predicate 

// Expansion d'un B_INSET
System.out.println("Expansion INSET - LIST_VAR");

	MyNode a1 	= 	(MyNode) astFactory.dupTree(#p1) ;
	MyNode a2 	= 	(MyNode) astFactory.dupTree(#p2) ;
	MyNode #t2 	= 	#(#B_INSET, #a1, #a2);

	#predicate	=	inset(#t2);
 ) 
		|				 #( B_NOT predicate ) 
		|				 #( B_DOM predicate ) 
		|				 #( B_MAX predicate ) 
		|				 #( B_MIN predicate ) 
		|				 #( B_CARD predicate ) 
		|				 #( B_RAN predicate ) 
		|				 #( B_NOTINSET predicate predicate ) 
		|				 #( B_SUBSET predicate predicate ) 
		|				 #( B_NOTSUBSET predicate predicate ) 
		|				 #( B_STRICTSUBSET predicate predicate ) 
		|				 #( B_NOTSTRICTSBSET predicate predicate ) 
		|				 #( B_CONCATSEQ predicate predicate ) 
		|				 #( B_PREAPPSEQ predicate predicate ) 
		|				 #( B_APPSEQ predicate predicate ) 
		|				 #( B_PREFIXSEQ predicate predicate ) 
		|				 #( B_SUFFIXSEQ predicate predicate ) 
		|				 #( B_RELATION predicate predicate ) 
		|				 #( B_PARTIAL predicate predicate ) 
		|				 #( B_TOTAL predicate predicate ) 
		|				 #( B_PARTIAL_INJECT predicate predicate ) 
		|				 #( B_TOTAL_INJECT predicate predicate ) 
		|				 #( B_PARTIAL_SURJECT predicate predicate ) 
		|				 #( B_TOTAL_SURJECT predicate predicate ) 
		|				 #( B_BIJECTION predicate predicate ) 
		|				 #( B_DOMAINRESTRICT predicate predicate ) 
		|				 #( B_RANGERESTRICT predicate predicate ) 
		|				 #( B_DOMAINSUBSTRACT predicate predicate ) 
		|				 #( B_RANGESUBSTRACT predicate predicate ) 
		|				 #( B_OVERRIDEFORWARD predicate predicate ) 
		|				 #( B_OVERRIDEBACKWARD predicate predicate ) 
		|				 #( B_RELPROD predicate predicate ) 
		|				 #( B_UNION predicate predicate ) 
		|				 #( B_INTER predicate predicate ) 
		|				 #( B_MAPLET predicate predicate ) 
		|	<a href="Normalize.html#cset_description">cset_description</a> 
		;
	
	
<a name="listInstanciation">listInstanciation</a>
		:				 #( B_COMMA listInstanciation listInstanciation ) 
		|	<a href="Normalize.html#paramRenameValuation">paramRenameValuation</a> 
		;
	
	
<a name="listNames">listNames</a>
		:				 #( B_COMMA listNames listNames ) 
		|	<a href="Normalize.html#nameRenamed">nameRenamed</a> 
		;
	
	
<a name="listTypedIdentifier">listTypedIdentifier</a>
		:				 #( B_COMMA listTypedIdentifier listTypedIdentifier ) 
		|	<a href="Normalize.html#typedIdentifier">typedIdentifier</a> 
		;
	
	
<a name="sets_declaration">sets_declaration</a>
		:				 #( B_SEMICOLON sets_declaration sets_declaration ) 
		|				 #( B_COMMA sets_declaration sets_declaration ) 
		|	<a href="Normalize.html#set_declaration">set_declaration</a> 
		;
	
	
<a name="list_valuation">list_valuation</a>
		:				 #( B_SEMICOLON list_valuation list_valuation ) 
		|	<a href="Normalize.html#set_valuation">set_valuation</a> 
		;
	
	
<a name="list_def">list_def</a>
		:				 #( LIST_DEF list_def list_def ) 
		|	<a href="Normalize.html#definition">definition</a> 
		;
	
	
/**
 * the Generalised Substitution Language
 **/
<a name="instruction">instruction</a>
		:				 #( PARALLEL instruction instruction ) 
		|				 #( SEQUENTIAL instruction instruction ) 
		|	&quot;skip&quot; 
		|				 #( "BEGIN" instruction ) 
		|				 #( "PRE" predicate instruction ) 
		|				 #( "ASSERT" predicate instruction ) 
		|				 #( "IF" predicate branche_then ( branche_elsif )* ( branche_else | ) ) 
		|				 #( "CHOICE" list_or ) 
		|				 #( "CASE" predicate branche_either ( branche_or )* ( branche_else | ) ) 
		|				 #( "ANY" listTypedIdentifier predicate instruction ) 
		|				 #( "LET" listTypedIdentifier list_equal instruction ) 
		|				 #( "SELECT" predicate instruction ( branche_when )* ( branche_else | ) ) 
		|				 #( "WHILE" predicate instruction variant_or_no ) 
		|				 #( "VAR" listTypedIdentifier instruction ) 
		|	<a href="Normalize.html#simple_affect">simple_affect</a> 
		;
	
	
<a name="listOperation">listOperation</a>
		:				 #( B_SEMICOLON listOperation listOperation ) 
		|	<a href="Normalize.html#operation">operation</a> 
		;
	
	
<a name="list_assertions">list_assertions</a>
		:				 #( B_SEMICOLON list_assertions list_assertions ) 
		|	<a href="Normalize.html#predicate">predicate</a> 
		;
	
	
<a name="predicate_with_prime">predicate_with_prime</a>
		:	&quot;tutu&quot; 
		;
	
	
/** 
 * La regle &quot;typedIdentifier&quot; permet de prendre en compte l&#039;extension 
 * de typage explicite de B&#039;
 **/
<a name="typedIdentifier">typedIdentifier</a>
		:				 #( B_INSET nameRenamed predicate ) 
		|	<a href="Normalize.html#nameRenamed">nameRenamed</a> 
		;
	
	
<a name="nameRenamed">nameRenamed</a>
		:	B_IDENTIFIER 
		|				 #( B_POINT nameRenamed B_IDENTIFIER ) 
		;
	
	
<a name="paramRenameValuation">paramRenameValuation</a>
		:				 #( B_LPAREN paramRenameValuation list_New_Predicate ) 
		|	<a href="Normalize.html#nameRenamed">nameRenamed</a> 
		;
	
	
<a name="list_New_Predicate">list_New_Predicate</a>
		:				 #( B_COMMA list_New_Predicate new_predicate ) 
		|	<a href="Normalize.html#new_predicate">new_predicate</a> 
		;
	
	
<a name="set_declaration">set_declaration</a>
		:				 #( B_EQUAL B_IDENTIFIER valuation_set ) 
		|	B_IDENTIFIER 
		;
	
	
<a name="valuation_set">valuation_set</a>
		:				 #( B_CURLYOPEN list_couple ) 
		|	<a href="Normalize.html#is_record">is_record</a> 
		|				 #( B_MULT valuation_set valuation_set ) 
		|				 #( B_ADD valuation_set valuation_set ) 
		|				 #( B_MINUS valuation_set valuation_set ) 
		|	B_IDENTIFIER 
		|	<a href="Normalize.html#basic_sets">basic_sets</a> 
		;
	
	
<a name="is_record">is_record</a>
		:				 #( "rec" listrecord ) 
		|				 #( "struct" listrecord ) 
		;
	
	
<a name="listrecord">listrecord</a>
		:				 #( B_COMMA listrecord listrecord ) 
		|	<a href="Normalize.html#a_record">a_record</a> 
		;
	
	
<a name="list_couple">list_couple</a>
		:				 #( t1:B_COMMA list_couple list_couple ) 
		|	<a href="Normalize.html#couple">couple</a> 
		;
	
	
/**
 * Les Types de base
 **/
<a name="basic_sets">basic_sets</a>
		:	&quot;INT&quot; 
		|	&quot;INT1&quot; 
		|	&quot;INTEGER&quot; 
		|	&quot;INTEGER1&quot; 
		|	&quot;BOOL&quot; 
		|	&quot;NAT&quot; 
		|	&quot;NAT1&quot; 
		|	&quot;NATURAL&quot; 
		|	&quot;NATURAL1&quot; 
		|	&quot;STRING&quot; 
		;
	
	
/**
 *	La regle &quot;a_record&quot; permet de definir le type de chaque champs
 **/
<a name="a_record">a_record</a>
		:				 #( B_SELECTOR B_IDENTIFIER predicate ) 
		|	<a href="Normalize.html#predicate">predicate</a> 
		;
	
	
<a name="couple">couple</a>
		:				 #( B_MAPLET a_set_value a_set_value ) 
		|				 #( B_LPAREN parent_couple ) 
		|	<a href="Normalize.html#a_set_value">a_set_value</a> 
		;
	
	
<a name="a_set_value">a_set_value</a>
		:	B_IDENTIFIER 
		|				 #( UNARY_MINUS B_NUMBER ) 
		|	B_NUMBER 
		|	&quot;TRUE&quot; 
		|	&quot;FALSE&quot; 
		;
	
	
<a name="parent_couple">parent_couple</a>
		:				 #( B_COMMA a_set_value a_set_value ) 
		|				 #( B_MAPLET a_set_value a_set_value ) 
		;
	
	
<a name="set_valuation">set_valuation</a>
		:				 #( B_EQUAL B_IDENTIFIER predicate ) 
		;
	
	
<a name="set_interval_value">set_interval_value</a>
		:				 #( B_EQUAL B_IDENTIFIER interval_declaration ) 
		;
	
	
<a name="interval_declaration">interval_declaration</a>
		:				 #( B_RANGE predicate predicate ) 
		;
	
	
/**
 * Attention un cas, one case
 *	- Une definition
 * Le cas lie a l&#039;acces a un fichier de definition a ete regle dans la phase de parsing
 **/
<a name="definition">definition</a>
		:				 #( B_DOUBLE_EQUAL paramName formalText 
	ADefinition adef = new ADefinition(def_name.getText(), def_param, (MyNode) astFactory.dupTree(#body.getFirstChild()));
	listdefinition.Add_AM ( adef );
 ) 
		;
	
	
<a name="formalText">formalText</a>
		:				 #( EXP_DEF predicate ) 
		|				 #( SUBST_DEF instruction ) 
		;
	
	
<a name="operation">operation</a>
		:				 #( OP_DEF ( ( #( tt:B_OUT listTypedIdentifier paramName 
	// Memorization pour introduction dans la table des symboles
	// ce n'est pas simple car les parametres de sortie sont introduit 
	// avant le nom de l'operation

 	#tt.memorizeOpname( #pp.getOpname() ); 
 ) instruction ) | ( paramName instruction ) ) ) 
		;
	
	
<a name="branche_then">branche_then</a>
		:				 #( "THEN" instruction ) 
		;
	
	
<a name="branche_elsif">branche_elsif</a>
		:				 #( "ELSIF" predicate instruction ) 
		;
	
	
<a name="branche_else">branche_else</a>
		:				 #( "ELSE" instruction ) 
		;
	
	
<a name="list_or">list_or</a>
		:				 #( "OR" list_or instruction ) 
		|	<a href="Normalize.html#instruction">instruction</a> 
		;
	
	
<a name="branche_either">branche_either</a>
		:				 #( "EITHER" predicate instruction ) 
		;
	
	
<a name="branche_or">branche_or</a>
		:				 #( "OR" predicate instruction ) 
		;
	
	
<a name="list_equal">list_equal</a>
		:				 #( B_AND list_equal list_equal ) 
		|	<a href="Normalize.html#an_equal">an_equal</a> 
		;
	
	
<a name="branche_when">branche_when</a>
		:				 #( "WHEN" predicate instruction ) 
		;
	
	
<a name="variant_or_no">variant_or_no</a>
		:				 #( "VARIANT" #( "INVARIANT" predicate ) predicate ) 
		|				 #( "INVARIANT" #( "VARIANT" predicate ) predicate ) 
		;
	
	
/**
 * Cinq cas 
 *	soit 	a,b,c := f(), g(), h()
 *	soit	a,b,c &lt;-- f(x)
 *	soit	a,b,c :( P )
 *	soit	a,b,c :: P
 *	soit	P.R (xx,yy)	ou sans parametre	P.R
 **/
<a name="simple_affect">simple_affect</a>
		:				 #( B_SIMPLESUBST list_func_call predicate 
	MyNode a1 	= 	(MyNode) astFactory.dupTree(#lf) ;
	MyNode a2 	= 	(MyNode) astFactory.dupTree(#lp) ;
	MyNode temp = 	#(#B_SIMPLESUBST, #a1, #a2);

	#simple_affect	=	affectation(#temp);
 ) 
		|				 #( B_OUT list_func_call func_call ) 
		|				 #( INSET list_func_call predicate ) 
		|				 #( B_BECOME_ELEM list_func_call predicate ) 
		|	<a href="Normalize.html#a_func_call">a_func_call</a> 
		;
	
	
<a name="an_equal">an_equal</a>
		:				 #( B_EQUAL B_IDENTIFIER predicate ) 
		;
	
	
/**
 * afin de prendre en compte 
 *	soit f (x,y,z)
 *	soit f (x) [z]
 *	soit f~(x) [z]
 *	soit f (x)~
 **/
<a name="func_call">func_call</a>
		:				 #( B_TILDE func_call ) 
		|				 #( APPLY_TO func_call list_New_Predicate ) 
		|				 #( B_LPAREN func_call list_New_Predicate ) 
		|				 #( B_QUOTEIDENT func_call func_call ) 
		|	<a href="Normalize.html#nameRenamed">nameRenamed</a> 
		;
	
	
<a name="func_param">func_param</a>
		:	<a href="Normalize.html#list_New_Predicate">list_New_Predicate</a> 
		;
	
	
<a name="new_predicate">new_predicate</a>
		:				 #( B_SEMICOLON new_predicate predicate ) 
		|				 #( B_PARALLEL new_predicate predicate ) 
		|	<a href="Normalize.html#predicate">predicate</a> 
		;
	
	
<a name="nameRenamedDecorated">nameRenamedDecorated</a>
		:				 #( B_CPRED nameRenamed ) 
		|	<a href="Normalize.html#nameRenamed">nameRenamed</a> 
		;
	
	
<a name="listPredicate">listPredicate</a>
		:				 #( B_COMMA listPredicate listPredicate ) 
		|	<a href="Normalize.html#predicate">predicate</a> 
		;
	
	
<a name="a_func_call">a_func_call</a>
		:				 #( A_FUNC_CALL afc 
//             if (modify = true)
//             {
//                 ## = #a;
//                 modify = false;
//             }
 ) 
		|	<a href="Normalize.html#afc">afc</a> 
		;
	
	
<a name="afc">afc</a>
		:				 #( FUNC_CALL_PARAM afc listPredicate ) 
		|				 #( B_QUOTEIDENT afc afc ) 
		|	<a href="Normalize.html#nameRenamed">nameRenamed</a> 
		;
	
	
<a name="list_func_call">list_func_call</a>
		:				 #( B_COMMA list_func_call list_func_call ) 
		|	<a href="Normalize.html#a_func_call">a_func_call</a> 
		;
	
	
<a name="affectation">affectation</a>
		:				 #( B_SIMPLESUBST list_func_call predicate 
System.out.println("AFFECTATION >>");

	getAPred(#lp);
	getAFunc(#lf);

System.out.println("list variable  : "+ #lf.toStringList());
System.out.println("list predicate : "+ #lp.toStringList());

System.out.println("v1 : "+ #T2.toStringList());
System.out.println("p1 : "+ #T4.toStringList());

	MyNode a1 	    = (MyNode) astFactory.dupTree(#T2) ;
	MyNode a2 	    = (MyNode) astFactory.dupTree(#T4) ;
	MyNode temp 	= #(#B_SIMPLESUBST, #a1, #a2);
	save[save_cmp]	= (MyNode) astFactory.dupTree(#temp) ;

 System.out.println("Il y a "+save_cmp+" et on a Temp ="+#temp.toStringList());

	if (T1 == null && T3 == null)
	{
		#res = (MyNode) astFactory.dupTree(#save[save_cmp]);
	}
	else if (T1 != null && T3 != null)
	{
		MyNode a3 	    = (MyNode) astFactory.dupTree(#T1) ;
		MyNode a4 	    = (MyNode) astFactory.dupTree(#T3) ;
		MyNode tmp  	= #(#B_SIMPLESUBST, #a3, #a4);

		save_cmp 	    = save_cmp+1;
		MyNode tmp1 	= affectation(#tmp);
		save_cmp 	    = save_cmp-1;

		if (abstract_m == true)
			#res 		= #(#[PARALLEL ,"||"], #tmp1,#save[save_cmp] );
		else
			#res 		= #(#[SEQUENTIAL,";"], #tmp1,#save[save_cmp] );
	}
	else
 	{ 
		#res = (MyNode) astFactory.dupTree(#save[save_cmp]);
		System.out.println(errors.ListIncompleted(lf.getLineNum()));
	}

System.out.println("AFFECTATION <<");
 ) 
		;
	
	
<a name="getAFunc">getAFunc</a>
		:				 #( B_COMMA list_func_call a_func_call 
	T1 = (MyNode) astFactory.dupTree(#a1);
	T2 = (MyNode) astFactory.dupTree(#r1);
 ) 
		|	<a href="Normalize.html#a_func_call">a_func_call</a> 
		;
	
	
<a name="getAPred">getAPred</a>
		:				 #( LIST_VAR ml_var nameRenamedDecorated 
System.out.println("LIST_VAR A B");
	T3 = (MyNode) astFactory.dupTree(#p1);
	T4 = (MyNode) astFactory.dupTree(#r1);
 ) 
		|	<a href="Normalize.html#nameRenamedDecorated">nameRenamedDecorated</a> 
		;
	
	
<a name="ml_var">ml_var</a>
		:				 #( LIST_VAR ml_var nameRenamedDecorated ) 
		|	<a href="Normalize.html#nameRenamedDecorated">nameRenamedDecorated</a> 
		;
	
	
<a name="getATerm">getATerm</a>
		:				 #( B_MULT expression_typage cset_description 
	T1 = (MyNode) astFactory.dupTree(#a1);
	T2 = (MyNode) astFactory.dupTree(#r1);
 ) 
		|	<a href="Normalize.html#cset_description">cset_description</a> 
		;
	
	
<a name="expression_typage">expression_typage</a>
		:				 #( B_MULT expression_typage cset_description ) 
		|	<a href="Normalize.html#cset_description">cset_description</a> 
		;
	
	
<a name="cset_description">cset_description</a>
		:	<a href="Normalize.html#basic_sets">basic_sets</a> 
		|	<a href="Normalize.html#cbasic_value">cbasic_value</a> 
		|				 #( "bool" predicate ) 
		|				 #( B_BRACKOPEN listPredicate ) 
		|				 #( B_RANGE predicate predicate ) 
		|	B_EMPTYSET 
		|				 #( B_CURLYOPEN cvalue_set ) 
		|	B_SEQEMPTY 
		|	<a href="Normalize.html#is_record">is_record</a> 
		|	<a href="Normalize.html#quantification">quantification</a> 
		|	<a href="Normalize.html#q_lambda">q_lambda</a> 
		;
	
	
<a name="inset">inset</a>
		:				 #( B_INSET ml_var expression_typage 
System.out.println("INSET >>");

	getAPred(#lf);

System.out.println("list variable: "+ #lf.toStringList());
//System.out.println("v1 : "+ #T3.toStringList());
System.out.println("v2 : "+ #T4.toStringList());

	MyNode a1 	= (MyNode) astFactory.dupTree(#T4) ;

	getATerm(#lp);

System.out.println("list predicat"+#lp.toStringList());
//System.out.println("p1 : "+ #T1.toStringList());
System.out.println("p2 : "+ #T2.toStringList());

	MyNode a2 	= (MyNode) astFactory.dupTree(#T2) ;

	MyNode temp 	= #(#B_INSET, #a1, #a2);

System.out.println("Il y a "+save_cmp+"et on a Temp ="+#temp.toStringList());

	save[save_cmp]	= (MyNode) astFactory.dupTree(#temp) ;
 
	if (T1 == null && T3 == null)
	{
		#res = (MyNode) astFactory.dupTree(#save[save_cmp]);
	}
	else if (T1 != null && T3 != null)
	{
		MyNode a3 	    = (MyNode) astFactory.dupTree(#T3) ;
		MyNode a4 	    = (MyNode) astFactory.dupTree(#T1) ;
		MyNode tmp  	= #(#B_INSET, #a3, #a4);

		save_cmp 	    = save_cmp+1;
		MyNode tmp1 	= inset(#tmp);
		save_cmp 	    = save_cmp-1;
		#res 		    = #(#[B_AND,"&"], #tmp1, #save[save_cmp] );
	}
	else
 	{ 
		#res = (MyNode) astFactory.dupTree(#save[save_cmp]);
		System.out.println(errors.ListIncompleted(lf.getLineNum()));
	}

System.out.println("INSET <<");
 ) 
		;
	
	
<a name="cbasic_value">cbasic_value</a>
		:	B_ASTRING 
		|	B_NUMBER 
		|				 #( B_TILDE predicate ) 
		|	<a href="Normalize.html#nameRenamedDecorated">nameRenamedDecorated</a> 
		|				 #( B_LPAREN predicate list_New_Predicate 
		String      st = #pp.toString();
		ADefinition ll = listdefinition.lookupName(st);

		if (ll != null)
        {
			afaire = true;
        }
		else 
		{
			afaire = false;
		}
//		if ((def == false) & (afaire == true))

		if ((afaire == true))
		{
            MyNode a1           = (MyNode) astFactory.dupTree(ll.getParam());
			MyNode a2           = (MyNode) astFactory.dupTree(#lp) ;
			MyNode temp 		= #(#[B_SIMPLESUBST,":="], #a1, #a2);

			MyNode #result 		= affectation(#temp);

            MyNode body         = (MyNode) astFactory.dupTree(ll.getBody());
            MyNode tmp          = #([SUBST_TO,"[["], #body, #result);

            uu.goal(#tmp);
            MyNode finalResult = (MyNode) uu.getAST();

            #cbasic_value		= #finalResult;
		}
		else
        {
			#cbasic_value 		= #(#B_LPAREN, #pp, #lp);
        }
 ) 
		|				 #( PARENT pred_func_composition ) 
		|				 #( B_QUOTEIDENT predicate predicate ) 
		|				 #( APPLY_TO predicate predicate ) 
		|	&quot;TRUE&quot; 
		|	&quot;FALSE&quot; 
		;
	
	
<a name="cvalue_set">cvalue_set</a>
		:				 #( B_SUCH list_var predicate ) 
		|				 #( B_COMMA cvalue_set predicate ) 
		|	<a href="Normalize.html#predicate">predicate</a> 
		;
	
	
<a name="quantification">quantification</a>
		:				 #( B_FORALL list_var predicate ) 
		|				 #( B_EXISTS list_var predicate ) 
		;
	
	
<a name="q_lambda">q_lambda</a>
		:				 #( B_LAMBDA q_operande ) 
		|				 #( "PI" q_operande ) 
		|				 #( "SIGMA" q_operande ) 
		|				 #( "UNION" q_operande ) 
		|				 #( "INTER" q_operande ) 
		;
	
	
<a name="list_var">list_var</a>
		:				 #( B_LPAREN list_identifier ) 
		|	<a href="Normalize.html#list_identifier">list_identifier</a> 
		;
	
	
<a name="pred_func_composition">pred_func_composition</a>
		:				 #( B_SEMICOLON pred_func_composition pred_func_composition ) 
		|				 #( B_PARALLEL pred_func_composition pred_func_composition ) 
		|				 #( B_COMMA pred_func_composition pred_func_composition ) 
		|	<a href="Normalize.html#predicate">predicate</a> 
		;
	
	
<a name="q_operande">q_operande</a>
		:				 #( B_SUCH list_var predicate predicate ) 
		;
	
	
<a name="list_identifier">list_identifier</a>
		:				 #( B_COMMA list_identifier list_identifier ) 
		|	B_IDENTIFIER 
		;
	
	
<a name="list_var_bis">list_var_bis</a>
		:				 #( B_LPAREN list_identifier_bis ) 
		|	<a href="Normalize.html#list_identifier_bis">list_identifier_bis</a> 
		;
	
	
<a name="list_identifier_bis">list_identifier_bis</a>
		:				 #( B_COMMA list_identifier_bis list_identifier_bis ) 
		|	B_IDENTIFIER 
		;
	
	
<a name="normalize">normalize</a>
		:				 #( B_LPAREN predicate #( B_SIMPLESUBST list_func_call predicate ) ) 
		|				 #( B_LPAREN predicate #( PARALLEL instruction instruction ) ) 
		|				 #( B_LPAREN predicate #( SEQUENTIAL instruction instruction ) ) 
		;

