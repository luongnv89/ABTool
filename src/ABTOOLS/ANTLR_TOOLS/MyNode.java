//
// Author          Boulanger Jean-Louis
//                 jean.louis.boulanger@gmail.com
//
// File            MyNode.java
// Description     A particular class which extends the CommonAST
// Copyright	   2000-2010 Jean-Louis Boulanger

// March 2000      v 0.0   
//       Creation
//
// April 2000      v 0.1     
//       Introduction de l'information de numero de colonne qui n'est pas
//       gere en standard par ANTLR
//       Introduction de l'information du nombre de token
//       Ajout d'operation de manipulation
//
// August 2000     v 0.2
//       Add Xmlserialisation for node
//
// December 2000   v 0.3
//       Add a field for initialisation memorisation
//
// April 2001      v 0.4
//       Add a particular field for memorize the operation name 
//
// April 2004      v 0.5
//       Restructuring and PACKAGING
//
// July  2004      v 0.6
//       Stabilized
//
// September 2004  v 1.1
//       retract attributes manipulation, we don't use it.
//
// October   2004  v 1.2
//       add specific comment to Node
// March 2009	   v 1.3
//		 Change directory name and mail adress

// This file is part of ABTOOLS.

//    ABTOOLS is free software: you can redistribute it and/or modify
//    it under the terms of the GNU LESSER General Public License as published by
//    the Free Software Foundation, either version 3 of the License, or
//    (at your option) any later version.

//    ABTOOLS is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//    GNU LESSER General Public License for more details.

//    You should have received a copy of the GNU LESSER General Public License
//    along with Foobar.  If not, see <http://www.gnu.org/licenses/>. 


// This file is provided WITHOUT ANY WARRANTY either expressed or implied.
// You may study, use, modify, and distribute it for non-commercial purposes.

/**
 * @author <a href="mailto:jean.louis.boulanger@gmail.com">Jean-Louis Boulanger</a>
 **/


package ABTOOLS.ANTLR_TOOLS;

import ABTOOLS.DEBUGGING.*;
import ABTOOLS.TYPING.*;

import antlr.collections.AST;
import antlr.CommonAST;
import antlr.Token;

// Java Paquetage
import java.io.*;        

import java.lang.reflect.*;
import java.util.Hashtable;
import java.util.Enumeration;


/** 
  Class TNode is an implementation of the AST interface
  and adds many useful features:
*/


public class MyNode extends CommonAST 
{

// Activate or Desactivate Debug information 
    private DEBUG         debugging = new DEBUG();
    private ErrorMessage  errors;

// Basic data
    protected int     ttype;
    protected String  text;
    protected int     lineNum = 0;
    protected String  op_name = "";

// The variable is or not initialised ?
    protected boolean init = false ;

// Usefull information for ABTools
    protected ABType    Btype = new ABType();
    protected boolean   InImp = false;

    static String tokenVocabulary;  

// Debugging and error management
    public void setDebug (DEBUG newdebug)
    {
	debugging = newdebug;
    }

    public void setErrors (ErrorMessage newerrors)
    {
	errors = newerrors;
    }

// Set specific comment 
    protected String Comment = "To be defined";

    public void setComment(String str)
    {
	Comment = str;
    }

    public String getComment()
    {
	return Comment;
    }

/** 
 * Set the token vocabulary to a tokentypes class generated by antlr.
 **/

    public static void setTokenVocabulary(String s) 
    {
	tokenVocabulary = s;
    }

    public void initialize(Token token) 
    {
	debugging.println("CLASS MyNode, OP initialize, PARAMETER token =" + token.toString());

        MyToken tok = (MyToken) token;
        setText(tok.getText());
        setType(tok.getType());
        setLineNum(tok.getLine());

	Btype = new ABType();
	InImp = false;
    }  
     
    public void initialize(AST tr) 
    {
	debugging.println("CLASS MyNode, OP initialize, PARAMETER AST =" + tr.toString());

        MyNode t = (MyNode) tr;
        setText(t.getText());
        setType(t.getType());
        setLineNum(t.getLineNum());

 	Btype = new ABType();
	InImp = false;
   }

    /** 
     *defined the BType
     **/
    public  ABType getBType()
    { 
	debugging.println("CLASS MyNode, OP getBType");
	return Btype.clone();
    }

    public void setBType(ABType type_) 
    { 
	debugging.println("CLASS MyNode, OP setBType");
	Btype = type_.clone();
    }

    /**
     * Manipulation of the variable called InImp
     **/

    public void InImp()
    {
	InImp = true;
    }

    public boolean isInImp()
    {
	return InImp;
    }

    /** 
     * I memorize the operation name in particular field
     **/

    public void memorizeOpname ( String Name)
    {
	op_name = Name;
    }

    public String getOpname ()
    {
	return op_name;
    }


    /**
     * Manipulating the fiel INIT ...
     **/

    public void initialized()
    {
	init = true;
    }
    public boolean isInitialized()
    {
	return init;
    }

    /**
     *  Get the token type for this node 
     **/

    public int getType() 
    {
	return ttype; 
    }
  
    /**
     * Set the token type for this node 
     **/
    public void setType(int ttype_) 
    { 
	ttype = ttype_; 
    }

    /** 
     *Get the line number for this node.
     * If the line number is 0, search for a non-zero line num among children 
     **/
    public int getLineNum() 
    { 
	if(lineNum != 0)
	    return lineNum; 
	else
	    if(down == null)
		return lineNum; 
	    else
		return ((MyNode)down).getLocalLineNum();
    }
  
    public int getLocalLineNum() 
    { 
	if(lineNum != 0)
	    return lineNum; 
	else
	    if(down == null)
		if(right == null)
		    return lineNum; 
		else
		    return ((MyNode)right).getLocalLineNum();
	    else
		return ((MyNode)down).getLocalLineNum();
    }
  
    /** 
     * Set the line number for this node 
     **/

    public void setLineNum(int lineNum_) 
    { 
	lineNum = lineNum_; 
    }
  
    /** 
     *Get the token text for this node 
     **/
    
    public String getText() 
    { 
	return text; 
    }
  
    /** 
     * Set the token text for this node 
     **/
    public void setText(String text_) 
    { 
	text = text_; 
    }

    /**
     * return a short string representation of the node 
     **/
    public String toString() 
    {
	return getText()   ;
    }

    public String toStringDecorated() 
    {
	return getText() +"("+Btype.toString() +")";
    }

    /**
     * converts an int tree token type to a name.
     * Does this by reflecting on nsdidl.IDLTreeTokenTypes,
     * and is dependent on how ANTLR 2.00 outputs that class. 
     **/
    public String getNameForType(int t) 
    {
	try{
	    Class        c = Class.forName(tokenVocabulary);
	    Field[] fields = c.getDeclaredFields();

	    //System.out.println();
	    //System.out.println(fields[t+1].getName());
	    //System.out.println(fields[t].getName());
	    //System.out.println(fields[t-1].getName());
	    //System.out.println(fields[t-2].getName());
	    //System.out.println(fields[t-3].getName());
	    //System.out.println(fields[t-4].getName());

	    if(t-2 < fields.length)
		return fields[t-2].getName();

	   } 
	catch (Exception e) 
	{ 
	    System.err.println(errors.Internal("MyNode.java","Exception: "+e)); 
	}

    return "unfoundtype: " + t;
  }

    /**
     * Aout 2000
     * Gestion de la generation du XML
     **/

    public void xmlSerializeNode(Writer out) 
    throws IOException 
    {
     	StringBuffer buf = new StringBuffer(100);
	buf.append("<");
	buf.append(getClass().getName()+" ");
	buf.append("text=\""+encode(getText()) +
		   "\" type=\""+getType() +
		   "\" line=\""+getLineNum() +           // On a ajoute le numero de la ligne, on verra pour la colonne
		   "\"/>");
	out.write(buf.toString());
    }         

} // End of File MyNode.java
